import { Controller, Post, Query } from "@nestjs/common";
import { BinanceService } from "../Services/BinanceService";
import { APIResponse } from "../Types/APIResponse.interface";
import { Interval } from "../Enums";
import { MapBinanceKlineToCreateCandle, MapIntervalToBinanceKlineInterval } from "../Mappers";
import SymbolRepository from "src/DAL/Repositories/Symbol.repository";

@Controller("candles")
export class CandlesController {
    constructor(private readonly symbolsRepository: SymbolRepository) { }

    @Post("update-symbols-list")
    async getSymbolsCandles(
        @Query("exchange") exchange,
        @Query("interval") interval: string,
        @Query("limit") limit: number
    ): Promise<APIResponse> {
        let _interval: string;
        try {
            _interval = MapIntervalToBinanceKlineInterval(Interval[interval])
        } catch (error) {
            return {
                success: false,
                message: "this is an invalid interval.",
                data: null,
            };
        }

        const symbols = await this.symbolsRepository.findAllSymbols();
        const addResult: object[] = [];

        for (const symbol of symbols) {
            let addedCandleCount: number = 0;

            let addedCount = await this.fetchAndStoreCandles(symbol.symbol, _interval, limit);
            addedCandleCount = addedCandleCount + addedCount;

            console.log(`fetched and stored ${addedCount} candles. symbol: ${symbol.symbol}. totalCount: ${addedCandleCount}`);

            while (addedCount === 1000) {
                addedCount = await this.fetchAndStoreCandles(symbol.symbol, _interval, limit);
                addedCandleCount = addedCandleCount + addedCount;
                console.log(`fetched and stored ${addedCount} candles. symbol: ${symbol.symbol}. totalCount: ${addedCandleCount}`);
            }

            addResult.push({
                symbol: symbol.symbol,
                addedCount: addedCandleCount
            });
        }

        return {
            success: true,
            message: "operation successfully completed.",
            data: addResult
        }
    }

    private async calculateStartTime(symbol: string, interval: string): Promise<number> {
        let startTime: number = new Date(2000, 1, 1).getTime();

        const _startTime = await this.binanceService.GetLatestCandleCloseTime(symbol, interval);
        startTime = _startTime ? _startTime : startTime;

        return startTime;
    }

    private async fetchAndStoreCandles(symbol: string, interval: string, limit: number = 1000): Promise<number> {
        const startTime = await this.calculateStartTime(symbol, interval);
        let fetchCandlesResult = await this.binanceService.FetchSymbolCandlesFromRemote(
            symbol.toUpperCase(),
            startTime,
            interval,
            limit
        );

        const candles = MapBinanceKlineToCreateCandle(fetchCandlesResult, symbol);

        if (candles.length > 0) {
            const addedCandles = await this.binanceService.AddCandlesToSymbol(candles, interval);
            const calculateMetasResult = await this.calculateCandleMetas(symbol, interval, addedCandles);
            await this.binanceService.AddCandleMetas(calculateMetasResult, interval);
            return addedCandles.length;
        }

        return 0;
    }

    // private async _calculateCandleMetas(symbol: string, interval: string, candles: CandleDocument[]): Promise<CreateMetas[]> {
    //     const previousCandle = await this.binanceService.GetPreviousCandleByCloseTime(symbol, interval, candles[0].closeTime);

    //     const metas: CreateMetas[] = [];

    //     if (previousCandle) {
    //         metas.push({
    //             candle: candles[0],
    //             difference: candles[0].closePrice - previousCandle.closePrice,
    //             rsi: null
    //         })
    //     } else {
    //         metas.push({
    //             candle: candles[0],
    //             difference: 0,
    //             rsi: null
    //         })
    //     }

    //     if (candles.length > 1) {
    //         for (let index = 1; index < candles.length; index++) {
    //             metas.push({
    //                 candle: candles[index],
    //                 difference: candles[index].closePrice - candles[index - 1].closePrice,
    //                 rsi: null
    //             })
    //         }
    //     }

    //     if (previousCandle) {

    //     }

    //     return metas;
    // }
}